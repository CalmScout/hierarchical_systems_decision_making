import numpy as np
import random as rand
import math

#Расчет матрицы парных сравнений по одной строке, в которой один элемент сравнивают со всеми (включая себя)
#Сравнивание осуществляется по шкале Саати, поэтому домустимыми значениями являются 1/9... 9
# Расчет осуществляется по методу построения функции принадлежности,
#который предложен Ротштейном А.П. Предполагается, что матрица парных сравнений кроме свойств
# диагональности и обратной симетричности, обладает еще и транзитивности
# warn(warning) - предупреждение:
# 0 все в порядке;
# -1 матрица содержит элементы меньше 1/9
# 1 матрица содержит элементы больше 9

def createConsistantPCM (str):
    warn =0
    if (np.max(str)<=9 and np.min(str)>1/9 ):
        n=len(str)
        if n<2 :
            print('строка парных сравнений должна содержать хотя бы 2 элемента')

        A = np.ones((n,n))
        k=None

        for i in range(len(str)):
            if str[i] == 1 :
                k = i
                break

        if k == None: print('строка парных сравнений должна содержать 1')

        #Номер базового элемента - порядковый номер элемента, с которым сравниваются остальные

        # формируем к-ю строку матрицы парных сравнений
        for i in range(n):
            A[k][i]= str[i]

        for i in range(n):
            for j in range(n):
                A[i][j]=A[k,j]/A[k,i]

    if ( np.max(A)>9 ):
        warn = 1
    elif(np.min(A)<1/9):
        warn = -1

    return A, warn


#
#Метод аоалогичный описаному выше, с еlинственным отличием, он создает слабо (порядково) согласованную матрицу парных сравнений
#Для этого типа матрицы выполняются только порядковые транзитивности. Это достигается округлением элемента в большую сторону при пересчете
#A[i][j]=A[k,j]/A[k,i]
def createWeakConsistantPCM (str):
    warn =0
    if (np.max(str)<=9 and np.min(str)>1/9 ):
        n=len(str)
        if n<2 :
            print('строка парных сравнений должна содержать хотя бы 2 элемента')

        A = np.ones((n,n))
        k=None

        for i in range(len(str)):
            if str[i] == 1 :
                k = i
                break

        if k == None: print('строка парных сравнений должна содержать 1')

        #Номер базового элемента - порядковый номер элемента, с которым сравниваются остальные

        # формируем к-ю строку матрицы парных сравнений
        for i in range(n):
            A[k][i]= str[i]

        for i in range(n):
            for j in range(n):
                if (i!=k and j!=k):
                    if A[k,j]/A[k,i]>1:
                        if (A[k,j]/A[k,i]-math.trunc(A[k,j]/A[k,i]))>0:
                             A[i][j]=math.ceil(A[k,j]/A[k,i])
                        else:
                            A[i][j] =(A[k, j] / A[k, i])+1
                    elif A[k,j]/A[k,i]<1:
                        if (A[k, i] / A[k, j] - math.trunc(A[k, i] / A[k, j])) > 0:
                            A[i][j] =1/math.ceil(A[k, i] / A[k, j])
                        else:
                            A[i][j] = 1/(A[k, i] / A[k, j]) + 1
                    else:
                        A[i][j] = 1
                else :
                    A[i][j] = A[k, j] / A[k, i]

    if ( np.max(A)>9 ):
        warn = 1
    elif(np.min(A)<1/9):
        warn = -1

    return A, warn



#Генерирует строку парных сравнений из n элеметнов
#в качестве оценок целые числа от 1 до 9
#обязательно формируется хотя бы одно значение 1 (сравнение элемента самого с собой)

def genRandLinePC(n):

    str = np.ones(int(n))

    for i in range(len(str)):
        str[i] = rand.randint(1, 9)

    flag = 0;
    # определение был ли сгенерировано значение 1 сразу, если нет случайным одразом переинициализируем один элемент на 1
    for i in range(len(str)):
        if str[i] == 1:
            flag = 1
            break

    if flag == 0:
        k = rand.randint(0, len(str) - 1)
        str[k] = int(1)

    print('line: ',str)
    return str


#Создает интервальную матрицу парных сравнений  путем расширения  точечных значений
#класической матрицы парных сравнений, которая была подана на вход.
#Хорошо генерирует согласованные Интервальные матрицы парных сравнений
#
#ВАЖНО, если на вход подать слабо согласованную матрицу, то так эе генерирует СОГЛАСОВАННУЮ интервальную,
# Иногда слабо порядково согласованную, это обусловлено тем что для интервальных матриц есть только понятие порядковой транзитивности,
# характерное для слабо согласованных четких матриц.

def createConsistantIPCM(PCM):
    L = np.ones((len(PCM), len(PCM)))
    U = np.ones((len(PCM), len(PCM)))

    for i in range(len(PCM)):
        for j in range(len(PCM)):
            if i == j:
                L[i][j] = 1
                U[i][j] = 1
            elif i < j:
                if PCM[i][j] >= 1:
                    L[i][j] = PCM[i][j]
                    U[i][j] = PCM[i][j] + rand.randint(1, 2)
                else : #Если обратное число больше 1 и меньше 3 (например 1.2) интервал формируется округлением в нижнюю и верхнюю стороны
                    if PCM[j][i]>1 and PCM[j][i] < 3 and PCM[j][i] !=2:
                        L[i][j] = 1 / math.ceil(PCM[j][i])
                        U[i][j] = 1 / math.floor(PCM[j][i])
                    elif PCM[j][i] ==2: #для 2 интервал увличивается на 1, чтоб не возникало ошибки деления на 0
                        L[i][j] = 1 / PCM[j][i]
                        U[i][j] = 1 / (PCM[j][i]-1)
                    else: #для всех остальных чисел интервал добавляется случайным способом
                        L[i][j] = 1 / PCM[j][i]
                        U[i][j] = 1 / (PCM[j][i]- rand.randint(1, 2))
            elif i > j:
                U[i][j] = 1 / L[j][i]
                L[i][j] = 1 / U[j][i]

    return L,U

